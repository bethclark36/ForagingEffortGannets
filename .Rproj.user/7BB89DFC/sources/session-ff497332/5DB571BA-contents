#Sep 2023 Beth Clark & David Pascall

#Load packages, data and set up ####
library(tidyverse) #1.3.0
library(cowplot) #1.0.0
#library(ggrepel)#0.8.2
#library(MuMIn)#1.43.15
#library(lme4)#1.1-21
#library(afex)#0.27-2
#library(optimx)#2020-4.2
#library(car)#3.0-8
#library(plotrix)#3.7-7
#library(arm)#1.11-2
#library(contrast)#0.22
library(DHARMa)#0.2.7
#library(ciTools)#0.6.1
library(spaMM)#4.4.0

sessionInfo()

rm(list=ls())

ms_theme <- theme_bw()+
  theme(text = element_text(size=20)) +
  theme(axis.title.x = element_text(margin = margin(t = 10))) +
  theme(legend.text=element_text(size=15)) +
  theme(axis.text=element_text(colour="black")) 

folder <- "C:/Users/potor/Sync/Documents2TB/Analysis/Iceland/Multicolony_comparison/"

dat <- read.csv(paste0(folder,"multicol_by_yr_newdata_capesm.csv"))

dat$sqrt.size. <- NULL
dat$sqrt.size <- sqrt(dat$Size)
head(dat)
dat$Dur_original <- dat$Dur
dat$Dur <- dat$Dur_original*10 #rescale for plotting

hist(dat$Dur)

#Check difference between colony count & gps year####
dat$GPS_year
dat$Year

range(dat$GPS_year)

dat$GPS_year_num <- dat$GPS_year - min(dat$GPS_year) + 1

dat$count_year <- as.numeric(ifelse(dat$Year == "2013/14",2013.5,as.character(dat$Year)))

year_diff <- abs(dat$count_year - dat$GPS_year)

range(year_diff)
mean(year_diff)

plot(dat$Lon, dat$Lat)
cor.test(dat$Lon, dat$Lat)
#correlated, so don't include Lat & Lon in same models

#Duration mods ####
#colony is a random intercept
#Lat and Lon with a matern covariance function to account for spatial autocorrelation
#"Earth" distance is used because locations are latlon and so on a sphere

size_lat_yr <- fitme(Dur ~ sqrt.size + Lat + GPS_year_num + (1|colony) + Matern(1|Lon + Lat), 
                     data=dat, control.dist = list(dist.method = "Earth"))

size_lon_yr <- fitme(Dur ~ sqrt.size + Lon + GPS_year_num + (1|colony) + Matern(1|Lon + Lat), 
                     data=dat, control.dist = list(dist.method = "Earth"))

size_lat <- fitme(Dur ~ sqrt.size + Lat + (1|colony) + Matern(1|Lon + Lat),
                  data=dat, control.dist = list(dist.method = "Earth"))

size_lon <- fitme(Dur ~ sqrt.size + Lon + (1|colony) + Matern(1|Lon + Lat), 
                  data=dat, control.dist = list(dist.method = "Earth"))

size_yr <- fitme(Dur ~ sqrt.size + GPS_year_num + (1|colony) + Matern(1|Lon + Lat), 
                 data=dat, control.dist = list(dist.method = "Earth"))

size <- fitme(Dur ~ sqrt.size + (1|colony) + Matern(1|Lon + Lat), 
              data=dat, control.dist = list(dist.method = "Earth"))

lat_yr <- fitme(Dur ~ Lat + GPS_year_num + (1|colony) + Matern(1|Lon + Lat), 
                data=dat, control.dist = list(dist.method = "Earth"))

lon_yr <- fitme(Dur ~ Lon + GPS_year_num + (1|colony) + Matern(1|Lon + Lat), 
                data=dat, control.dist = list(dist.method = "Earth"))

lat <- fitme(Dur ~ Lat + (1|colony) + Matern(1|Lon + Lat),  
             data=dat, control.dist = list(dist.method = "Earth"))

lon <- fitme(Dur ~ Lon + (1|colony) + Matern(1|Lon + Lat), 
             data=dat, control.dist = list(dist.method = "Earth"))

yr <- fitme(Dur ~ GPS_year_num + (1|colony) + Matern(1|Lon + Lat), 
            data=dat, control.dist = list(dist.method = "Earth"))

null <- fitme(Dur ~ (1|colony) + Matern(1|Lon + Lat),
              data=dat, control.dist = list(dist.method = "Earth"))

#calculate AIC - we are using marginal
AIC(size_lat_yr)
AIC(size_lon_yr)
AIC(size_lat)
AIC(size_lon)
AIC(size_yr)
AIC(size)
AIC(lat_yr)
AIC(lon_yr)
AIC(lat)
AIC(lon)
AIC(yr)
AIC(null)

#calculate pseudo R2 
pseudoR2(size_lat_yr)
pseudoR2(size_lon_yr)
pseudoR2(size_lat)
pseudoR2(size_lon)
pseudoR2(size_yr)
pseudoR2(size)
pseudoR2(lat_yr)
pseudoR2(lon_yr)
pseudoR2(lat)
pseudoR2(lon)
pseudoR2(yr)
pseudoR2(null)

#size_lat is the top model, so check the fit using DHARMa
plot(DHARMa::simulateResiduals(size_lat))

#good, so use to predict for plots

#Duration plots predict latitude ####

border <- 1
newdat <- tidyr::expand(data = dat,
                        Lat = seq((min(Lat)-border), 
                                  (max(Lat)+border),length=100),
                        sqrt.size = mean(sqrt.size)) %>%
  data.frame()

pred <- predict(size_lat, newdat, 
                re.form=NA, intervals = "fixefVar")
pred <- as.data.frame(cbind(pred, attr(pred, "intervals")))
newdat$pred <- pred$V1 
newdat$lower <- pred$fixefVar_0.025
newdat$upper <- pred$fixefVar_0.975

unique(dat$colony)

#correct character coding error
dat$colony <- ifelse(dat$colony == "Skr\xfa\xf0ur" ,"Skr??ur",dat$colony)
dat$colony <- ifelse(dat$colony == "Store Ulv\xf8yhomen" ,"Store Ulv?yhomen",dat$colony)

#set colours
dat$col_col <- ifelse(as.character(dat$colony) %in% 
                        c("Ailsa Craig","Baccalieu Island","Bonaventure Island",
                          "Bull Rock","Heligoland","Lambay","Little Skellig",
                          "St Kilda","Sule Skerry"),"grey","black")

#set shapes
dat$col_shape <- ifelse(as.character(dat$colony) %in% 
   c("Ailsa Craig","Baccalieu Island","Bonaventure Island",
     "Bull Rock","Heligoland","Lambay","Little Skellig",
     "St Kilda","Sule Skerry"),16,0)
dat$col_shape <- ifelse(as.character(dat$colony) == 
                        "Alderney",18, dat$col_shape)
dat$col_shape <- ifelse(as.character(dat$colony) == 
                          "Bass Rock",2, dat$col_shape)
dat$col_shape <- ifelse(as.character(dat$colony) == 
                          "Bempton",3, dat$col_shape)
dat$col_shape <- ifelse(as.character(dat$colony) == 
                          "Funk Island",4, dat$col_shape)
dat$col_shape <- ifelse(as.character(dat$colony) == 
                          "Grassholm",1, dat$col_shape)
dat$col_shape <- ifelse(as.character(dat$colony) == 
                          "Great Saltee",17, dat$col_shape)
dat$col_shape <- ifelse(as.character(dat$colony) == 
                          "Rouzic",6, dat$col_shape)
dat$col_shape <- ifelse(as.character(dat$colony) == 
                          "Skr??ur",0, dat$col_shape)
dat$col_shape <- ifelse(as.character(dat$colony) == 
                          "Store Ulv?yhomen",25, dat$col_shape)
dat$col_shape <- ifelse(as.character(dat$colony) == 
                          "Storstappen",8, dat$col_shape)
dat$col_shape <- ifelse(as.character(dat$colony) == 
                          "Vestmannaeyjar",15, dat$col_shape)
dat$col_shape <- ifelse(as.character(dat$colony) == 
                          "Cape St Mary's",5, dat$col_shape)

head(newdat)
dl3 <-ggplot(newdat, aes(x=Lat, y=pred)) + 
  geom_line()+
  geom_ribbon(aes(ymin = lower, ymax = upper), 
              colour = "grey", alpha = 0.2) +  
  geom_point(data = dat, aes(x=Lat, y=Dur),
              shape = dat$col_shape,
                              fill = dat$col_col,
                              color = dat$col_col,
                              size=3.5,stroke=1.1)+
  scale_y_continuous(expand = c(0, 0), limits=c(0, 425)) +
  scale_x_continuous(expand = c(0, 0), 
                     limits=c(min(dat$Lat)- border, 
                              max(dat$Lat)+ border)) +
  ms_theme +
  theme(legend.position = "none") +
  geom_line()+
  theme(axis.title.y = element_blank(),axis.title.x = element_blank());dl3

#Duration plots predict colony size ####
border <- 11.74734
newdat <- tidyr::expand(data = dat,
                        sqrt.size = seq(0, 
                        (max(sqrt.size) + border),length=100),
                        Lat = mean(Lat))
pred <- predict(size_lat, newdat, 
                re.form=NA, intervals = "fixefVar")
pred <- as.data.frame(cbind(pred, attr(pred, "intervals")))
newdat$pred <- pred$V1 
newdat$lower <- pred$fixefVar_0.025
newdat$upper <- pred$fixefVar_0.975

ds3 <-ggplot(newdat, aes(x=sqrt.size, y=pred)) + 
  geom_line()+
  geom_ribbon(aes(ymin = lower, ymax = upper), 
              colour = "grey", alpha = 0.2) +  
  geom_point(data = dat, aes(x=sqrt.size, y=Dur),
             shape = dat$col_shape,
             fill = dat$col_col,
             color = dat$col_col,
             size=3.5,stroke=1.1)+
  scale_y_continuous(expand = c(0, 0), limits=c(0, 425)) +
  scale_x_continuous(expand = c(0, 0), 
                     limits=c(0, 
                              max(dat$sqrt.size)+ border)) +
  ms_theme +
  theme(legend.position = "none") +
  geom_line()+
  theme(axis.title.y = element_blank(),axis.title.x = element_blank());ds3

plot_grid(ds3,dl3,ncol = 2)

#Maximum distance models####
size_lat_yr <- fitme(Maxdist ~ sqrt.size + Lat + GPS_year_num + (1|colony) + Matern(1|Lon + Lat), 
                     data=dat, control.dist = list(dist.method = "Earth"))

size_lon_yr <- fitme(Maxdist ~ sqrt.size + Lon + GPS_year_num + (1|colony) + Matern(1|Lon + Lat), 
                     data=dat, control.dist = list(dist.method = "Earth"))

size_lat <- fitme(Maxdist ~ sqrt.size + Lat + (1|colony) + Matern(1|Lon + Lat),
                  data=dat, control.dist = list(dist.method = "Earth"))

size_lon <- fitme(Maxdist ~ sqrt.size + Lon + (1|colony) + Matern(1|Lon + Lat), 
                  data=dat, control.dist = list(dist.method = "Earth"))

size_yr <- fitme(Maxdist ~ sqrt.size + GPS_year_num + (1|colony) + Matern(1|Lon + Lat), 
                 data=dat, control.dist = list(dist.method = "Earth"))

size <- fitme(Maxdist ~ sqrt.size + (1|colony) + Matern(1|Lon + Lat), 
              data=dat, control.dist = list(dist.method = "Earth"))

lat_yr <- fitme(Maxdist ~ Lat + GPS_year_num + (1|colony) + Matern(1|Lon + Lat), 
                data=dat, control.dist = list(dist.method = "Earth"))

lon_yr <- fitme(Maxdist ~ Lon + GPS_year_num + (1|colony) + Matern(1|Lon + Lat), 
                data=dat, control.dist = list(dist.method = "Earth"))

lat <- fitme(Maxdist ~ Lat + (1|colony) + Matern(1|Lon + Lat),  
             data=dat, control.dist = list(dist.method = "Earth"))

lon <- fitme(Maxdist ~ Lon + (1|colony) + Matern(1|Lon + Lat), 
             data=dat, control.dist = list(dist.method = "Earth"))

yr <- fitme(Maxdist ~ GPS_year_num + (1|colony) + Matern(1|Lon + Lat), 
            data=dat, control.dist = list(dist.method = "Earth"))

null <- fitme(Maxdist ~ (1|colony) + Matern(1|Lon + Lat),
              data=dat, control.dist = list(dist.method = "Earth"))

#calculated AIC - we are using marginal
AIC(size_lat_yr)
AIC(size_lon_yr)
AIC(size_lat)
AIC(size_lon)
AIC(size_yr)
AIC(size)
AIC(lat_yr)
AIC(lon_yr)
AIC(lat)
AIC(lon)
AIC(yr)
AIC(null)

#calculate pseudo R2 
pseudoR2(size_lat_yr)
pseudoR2(size_lon_yr)
pseudoR2(size_lat)
pseudoR2(size_lon)
pseudoR2(size_yr)
pseudoR2(size)
pseudoR2(lat_yr)
pseudoR2(lon_yr)
pseudoR2(lat)
pseudoR2(lon)
pseudoR2(yr)
pseudoR2(null)

#size_lat is not the top model, but is within 2 AIC and has a bigger pseudo r2,
#so plot to match
#check the fit using DHARMa
plot(DHARMa::simulateResiduals(size_lat))

#good, so plot
#Predict max dist v latitude ####
border <- 1
newdat <- tidyr::expand(data = dat,
                        Lat = seq((min(Lat)-border), 
                                  (max(Lat)+border),length=100),
                        sqrt.size = mean(sqrt.size)) %>%
  data.frame()
pred <- predict(size_lat, newdat, 
                re.form=NA, intervals = "fixefVar")
pred <- as.data.frame(cbind(pred, attr(pred, "intervals")))
newdat$pred <- pred$V1 
newdat$lower <- pred$fixefVar_0.025
newdat$upper <- pred$fixefVar_0.975


head(newdat)
ml3 <-ggplot(newdat, aes(x=Lat, y=pred)) + 
  geom_line()+
  geom_ribbon(aes(ymin = lower, ymax = upper), 
              colour = "grey", alpha = 0.2) +  
  geom_point(data = dat, aes(x=Lat, y=Maxdist),
             shape = dat$col_shape,
             fill = dat$col_col,
             color = dat$col_col,
             size=3.5,stroke=1.1)+
  scale_y_continuous(expand = c(0, 0), limits=c(0, 330)) +
  scale_x_continuous(expand = c(0, 0), 
                     limits=c(min(dat$Lat)- border, 
                              max(dat$Lat)+ border)) +
  ms_theme +
  theme(legend.position = "none") +
  geom_line()+
  theme(axis.title.y = element_blank(),axis.title.x = element_blank());ml3

#Predict size max ####
border <- 11.74734
newdat <- tidyr::expand(data = dat,
                        sqrt.size = seq(0, 
                                        (max(sqrt.size) + border),length=100),
                        Lat = mean(Lat))
pred <- predict(size_lat, newdat, 
                re.form=NA, intervals = "fixefVar")
pred <- as.data.frame(cbind(pred, attr(pred, "intervals")))
newdat$pred <- pred$V1 
newdat$lower <- pred$fixefVar_0.025
newdat$upper <- pred$fixefVar_0.975

ms3 <-ggplot(newdat, aes(x=sqrt.size, y=pred)) + 
  geom_line()+
  geom_ribbon(aes(ymin = lower, ymax = upper), 
              colour = "grey", alpha = 0.2) +  
  geom_point(data = dat, aes(x=sqrt.size, y=Maxdist),
             shape = dat$col_shape,
             fill = dat$col_col,
             color = dat$col_col,
             size=3.5,stroke=1.1)+
  scale_y_continuous(expand = c(0, 0), limits=c(0, 330)) +
  scale_x_continuous(expand = c(0, 0), 
                     limits=c(0, 
                              max(dat$sqrt.size)+ border)) +
  ms_theme +
  theme(legend.position = "none") +
  geom_line()+
  theme(axis.title.y = element_blank(),axis.title.x = element_blank());ms3

#plot grids ####
plot_grid(ds3, dl3, ms3, ml3, ncol=2)

#save plots
png("C:/Users/potor/Sync/Documents2TB/Analysis/Iceland/Multicolony_comparison/newdata/model_by_yr_capesm_matern.png",
    width=5000,height=5000,res=400)
plot_grid(ds3, dl3, ms3, ml3, ncol=2)
dev.off()




